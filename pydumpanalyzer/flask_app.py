''' this file is home to the flask-based application that is the following:
    1. Receiver and storer of symbol files and executables
    2. Receiver and storer of crash dumps
    3. Analyzer of crash dumps
    4. Windows symbol server when accessible via an endpoint
'''
import datetime
import enum
import io
import itertools
import os
import pickle
import traceback

import flask
import flask_selfdoc
from werkzeug.exceptions import HTTPException

import __version__
import _html
import utility
from csmlog_setup import enableConsoleLogging, getLogger
from storage import Storage

CACHED_ANALYSIS_FILE_NAME = 'analysis.pickle'
THIS_DIR = os.path.abspath(os.path.dirname(__file__))
ROOT_STORAGE_LOCATION = os.path.join(THIS_DIR, 'storage')
WINDOWS_SYMBOLS_LOCATION = os.path.join(ROOT_STORAGE_LOCATION, "WindowsSymbols")

app = flask.Flask("PyDumpAnalyzerFlaskApp")
auto = flask_selfdoc.Autodoc(app)
logger = getLogger(__file__)

class WEBPAGES_NAVBAR(enum.Enum):
    ''' enum with all top level web pages for the navbar '''
    API_Docs = '/show/apidocs/'

class WEBPAGES_NOT_NAVBAR(enum.Enum):
    ''' enum with all outward web pages. Ones that are in here,
    but not in WEBPAGES_NAVBAR are not shown in the navbar '''
    Add_Item = '/add'
    Home = '/'
    View_Application_Table = '/show/application_table/<applicationName>'
    Get_File = '/get/file/<applicationName>/<rowUid>/<column>'

WEBPAGES = enum.Enum('WEBPAGES', [(i.name, i.value) for i in itertools.chain(WEBPAGES_NAVBAR, WEBPAGES_NOT_NAVBAR)])

@app.context_processor
def injectTemplateContext():
    ''' everything returned in this function is added to the context for all
    templates that flask renders. Only global, template driven things should be here. '''
    return {
        # this is the version of PDA...
        'pda_version' : __version__.__version__,
        'navItems' : [(a.name.replace('_', ' '), a.value) for a in list(WEBPAGES_NAVBAR)]
    }

@app.route(WEBPAGES.API_Docs.value, methods=['GET'])
def apiDocumentation():
    ''' returns a lovely documentation page of all supported APIs. Generated by flask_selfdoc. '''
    return flask.render_template('base.html', html_content=auto.html())

@app.route(WEBPAGES.Home.value, methods=['GET'])
def home():
    ''' the home page for the app '''
    with Storage() as storage:
        cursor = storage.database.execute("SELECT Name FROM Applications")
        table = _html.HtmlTable.fromCursor(cursor, classes='content', name="Applications")

        if not table:
            table = '<p>No applications have reported back to PDA... yet!</p>'
        else:
            table.modifyAllRows(lambda row: [_html.getHtmlLinkString(flask.url_for('viewApplicationTable', applicationName=row[0]), row[0])])

    return flask.render_template('home.html', html_content=table)

@app.route(WEBPAGES.View_Application_Table.value, methods=['GET'])
def viewApplicationTable(applicationName):
    ''' used to give back a view of the given database table '''

    # todo.. i think this whole function's body should likely be in storage.py
    with Storage() as storage:
        tableName = storage.getApplicationTableName(applicationName)
        if tableName:
            cursor = storage.database.execute("SELECT * FROM %s" % tableName)
            table = _html.HtmlTable.fromCursor(cursor, classes='content', name=applicationName)
        else:
            logger.warning("User requested application (%s) which doesn't have a matching table" % applicationName)
            table = None

        if table:
            def getLinks(row):
                ''' helper to get links to files in the current table '''
                rowUid = row[table.tableHeaders.index("UID")]
                for columnName in 'SymbolsFile', 'ExecutableFile', 'CrashDumpFile':
                    url = flask.url_for("getFile", applicationName=applicationName, rowUid=rowUid, column=columnName)
                    index = table.tableHeaders.index(columnName)
                    cellValue = storage.getApplicationCell(applicationName, rowUid, columnName + "Name")
                    if cellValue:
                        row[index] = _html.getHtmlLinkString(url, cellValue)
                return row
            table.modifyAllRows(getLinks)
            table.removeColumns(['SymbolsFileName', 'ExecutableFileName', 'CrashDumpFileName'])

            return flask.render_template('table_view.html', table_content=table, title=applicationName)
        else:
            flask.abort(404)

@app.errorhandler(Exception)
def error_handler(e):
    ''' this will handle all http errors we may encounter with a custom template '''
    logger.error("Giving back an error: %s\n... that error was encountered serving: %s" % (str(e), flask.request.path))

    # if an assertion gets here, it means something has gone very wrong.
    if not hasattr(e, 'code'):
        try:
            txt = "Unknown Error made it to the error handler: " + traceback.format_exc()
        except:
            txt = "Unknown Error"

        logger.error(txt)
        return flask.render_template('error.html', code=400, errString=utility.textToSafeHtmlText(txt)), 400

    return flask.render_template('error.html', code=e.code, errString=str(e)), e.code

@app.route(WEBPAGES.Get_File.value, methods=['GET'])
def getFile(applicationName, rowUid, column):
    ''' this handler is not documented for external use.
    From applicationName, rowUid, column (name) we can get the blob assoicated '''
    with Storage() as s:
        blob = s.getApplicationCell(applicationName, rowUid, column)
        if not blob:
            flask.abort(404)

        # if we can get the 'real name', use it
        fileName = None
        if column in ('SymbolsFile', 'ExecutableFile', 'CrashDumpFile'):
            fileName = s.getApplicationCell(applicationName, rowUid, column + "Name")

    if isinstance(blob, str):
        blob = blob.encode()

    return flask.send_file(io.BytesIO(blob), as_attachment=True, attachment_filename=fileName)

@app.route(WEBPAGES.Add_Item.value, methods=['POST'])
@auto.doc()
def addHandler():
    ''' this handler is called when an item is being added via a POST request. A single call to this API shall not have unrelated Symbols/Executable/CrashDump files.
        In other words, do not give an Execuable that isn't related to the given Symbols file. Do seperate API calls for unrelated files.

    Required form-data Body Fields:
    OperatingSystem: String: (Should be "Windows")
    Application:     String: The name of the application this addition is related to

    At least one of the following is also required:
    SymbolsFile:     File: Symbols file for the application (On Windows a .pdb file can be given)
    ExecutableFile:  File: The executable to be debugged later (Can be a .exe, .dll, etc.)
    CrashDumpFile:   File: The dump file to be analyzed. (On Windows, the crash dump can be sent at a different time from the ExecutableFile and SymbolsFile)

    Optional form-data Body Fields:
    ApplicationVersion: String: Version for the application
    Tag:                String: Arbitrary tag for this upload. (Can be used for later filtering)
    '''
    with Storage() as storage:
        return storage.addFromAddRequest(flask.request)

if __name__ == '__main__':
    app.url_map.strict_slashes = False
    enableConsoleLogging()
    app.run()

